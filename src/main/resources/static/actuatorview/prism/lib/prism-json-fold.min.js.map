{"version":3,"file":"prism-json-fold.min.js","sources":["../src/utils/index.js","../src/parsers/objects.js","../src/parsers/arrays.js","../index.js","../src/parser.js"],"sourcesContent":["/*\n * prism-json-fold\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nmodule.exports = {\n  /**\n   * Returns a boolean telling is line is one of the given\n   * punctuation or not\n   *\n   * @method isPunctuation\n   *\n   * @param  {String}      line\n   * @param  {Array}      values\n   *\n   * @return {Boolean}\n   */\n  isPunctuation (line, values) {\n    return values.some(function (value) {\n      return line.indexOf(`punctuation\">${value}`) > -1\n    })\n  },\n\n  /**\n   * Returns a boolean telling is line is one of the given operators\n   *\n   * @method isOperator\n   *\n   * @param  {String}   line\n   * @param  {Array}   values\n   *\n   * @return {Boolean}\n   */\n  isOperator (line, values) {\n    return values.some(function (value) {\n      return line.indexOf(`operator\">${value}`) > -1\n    })\n  },\n\n  /**\n   * Retuns a boolean telling if line is a property\n   *\n   * @method isProperty\n   *\n   * @param  {String}   line\n   *\n   * @return {Boolean}\n   */\n  isProperty (line) {\n    return line.indexOf('property\">') > -1\n  },\n\n  /**\n   * Returns the span for the main block\n   *\n   * @method getBlock\n   *\n   * @param  {String} identifier\n   *\n   * @return {String}\n   */\n  getBlock (identifier) {\n    return `<span class=\"block block-${identifier}\"><i class=\"caret\"></i>`\n  },\n\n  /**\n   * Returns the span for the block wrapper\n   *\n   * @method getBlockWrapper\n   *\n   * @return {String}\n   */\n  getBlockWrapper () {\n    return '<span class=\"block-wrapper\">'\n  },\n\n  /**\n   * Returns whitspaces from the front of the span tag\n   *\n   * @method getSpaces\n   *\n   * @param  {String}  content\n   *\n   * @return {String}\n   */\n  getSpaces (content) {\n    const match = content.match(/^(\\s+)/)\n    return match ? match[1] : ''\n  },\n\n  /**\n   * Returns a boolean telling if current content is a closing\n   * array of objectq\n   *\n   * @method isClosingBlock\n   *\n   * @param  {String}       content\n   *\n   * @return {Boolean}\n   */\n  isClosingBlock (content) {\n    return content.indexOf('punctuation\">}') > -1 || content.indexOf('punctuation\">]') > -1\n  }\n}\n","/*\n * prism-json-fold\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst utils = require('../utils')\n\nmodule.exports = {\n  /**\n   * Returns a boolean telling if stack and the current line\n   * content looks like an object literal\n   *\n   * @method matches\n   *\n   * @param  {Array} stack\n   * @param  {String} content\n   * @param  {Number} index\n   *\n   * @return {Boolean}\n   */\n  matches (stack, content, index) {\n    /**\n     * If object is part an array\n     *\n     * [\n     *   {\n     *   },\n     *   {\n     *   }\n     * ]\n     */\n    if (utils.isPunctuation(content, ['{'])) {\n      if (!stack[index - 1]) {\n        return false\n      }\n      return utils.isPunctuation(stack[index - 1], ['[', ','])\n    }\n\n    /**\n     * If it's starting of a keyed object.\n     *\n     * \"user\": {\n     * }\n     */\n    if (stack.length < index + 2 || !utils.isProperty(content)) {\n      return false\n    }\n\n    return utils.isOperator(stack[index + 1], [':']) && utils.isPunctuation(stack[index + 2], ['{'])\n  },\n\n  /**\n   * Returns the new content block for the matched object node. This method\n   * can blindly believe that content, stack is validated properly using\n   * the `matches` method.\n   *\n   * @method getContent\n   *\n   * @param  {Array}   stack\n   * @param  {String}  content\n   * @param  {Number}  index\n   *\n   * @return {Object} { content: String, jump: Number }\n   */\n  getContent (stack, content, index) {\n    if (utils.isPunctuation(content, ['{'])) {\n      const wrappedContent = `${content.trim()}</span>`\n      const openingBlock = `${utils.getSpaces(content)}${utils.getBlock('object')}`\n      const block = `${openingBlock}${wrappedContent}${utils.getBlockWrapper()}`\n      return { content: block, jump: 0 }\n    }\n\n    const operator = `${stack[index + 1]}</span>`\n    const punctuation = `${stack[index + 2]}</span>`\n    const wrappedContent = `${content.trim()}</span>`\n    const openingBlock = `${utils.getSpaces(content)}${utils.getBlock('keyed-object')}`\n\n    const block = `${openingBlock}${wrappedContent}${operator}${punctuation}${utils.getBlockWrapper()}`\n    return { content: block, jump: 2 }\n  }\n}\n","/*\n * prism-json-fold\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst utils = require('../utils')\n\nmodule.exports = {\n  /**\n   * Returns a boolean telling if stack and the current line\n   * content looks like an object literal\n   *\n   * @method matches\n   *\n   * @param  {Array} stack\n   * @param  {String} content\n   * @param  {Number} index\n   *\n   * @return {Boolean}\n   */\n  matches (stack, content, index) {\n    /**\n     * If array is part of an array\n     *\n     * [\n     *   [],\n     *   []\n     * ]\n     */\n    if (utils.isPunctuation(content, ['['])) {\n      if (!stack[index - 1]) {\n        return false\n      }\n      return utils.isPunctuation(stack[index - 1], ['[', ','])\n    }\n\n    /**\n     * If it's starting of a keyed object.\n     *\n     * \"user\": {\n     * }\n     */\n    if (stack.length < index + 2 || !utils.isProperty(content)) {\n      return false\n    }\n\n    return utils.isOperator(stack[index + 1], [':']) && utils.isPunctuation(stack[index + 2], ['['])\n  },\n\n  /**\n   * Returns the new content block for the matched object node. This method\n   * can blindly believe that content, stack is validated properly using\n   * the `matches` method.\n   *\n   * @method getContent\n   *\n   * @param  {Array}   stack\n   * @param  {String}  content\n   * @param  {Number}  index\n   *\n   * @return {Object} { content: String, jump: Number }\n   */\n  getContent (stack, content, index) {\n    if (utils.isPunctuation(content, ['['])) {\n      const wrappedContent = `${content.trim()}</span>`\n      const openingBlock = `${utils.getSpaces(content)}${utils.getBlock('array')}`\n      const block = `${openingBlock}${wrappedContent}${utils.getBlockWrapper()}`\n      return { content: block, jump: 0 }\n    }\n\n    const operator = `${stack[index + 1]}</span>`\n    const punctuation = `${stack[index + 2]}</span>`\n    const wrappedContent = `${content.trim()}</span>`\n    const openingBlock = `${utils.getSpaces(content)}${utils.getBlock('keyed-array')}`\n\n    const block = `${openingBlock}${wrappedContent}${operator}${punctuation}${utils.getBlockWrapper()}`\n    return { content: block, jump: 2 }\n  }\n}\n","/*\n * prims-json-fold\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst parser = require('./src/parser');\n\n(function () {\n  /**\n   * Standard check for prism plugins.\n   */\n  if ((typeof self !== 'undefined' && !self.Prism) || (typeof global !== 'undefined' && !global.Prism)) {\n    return\n  }\n\n  Prism.hooks.add('before-insert', (env) => {\n    if (env.language === 'json') {\n      env.highlightedCode = parser(env.highlightedCode)\n    }\n  })\n\n  /**\n   * Add event listener to toggle the groups\n   */\n  Prism.hooks.add('complete', function (env) {\n    if (env.language === 'json') {\n      env.element.querySelectorAll('.block i').forEach(function (block) {\n        block.addEventListener('click', function () {\n          this.parentElement.classList.toggle('open')\n        })\n      })\n    }\n  })\n})()\n","/*\n * prism-json-fold\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n*/\n\nconst utils = require('./utils')\nconst parsers = require('./parsers')\n\n/**\n * Parses the prism HTML content and wraps the JSON objects\n * and arrays inside other spans to make them foldable\n *\n * @method parser\n *\n * @param  {String} content\n *\n * @return {String}\n */\nmodule.exports = function parser (content) {\n  const lines = content.split('</span>')\n  let newLines = ''\n  let index = 0\n\n  while (index < lines.length) {\n    const line = lines[index]\n\n    if (utils.isClosingBlock(line)) {\n      /**\n       * Here we close 3 spans in total and here's why\n       *\n       * 1. First span is the to close the current span, which was removed during the `split` call.\n       * 2. 2nd span is the `.block-wrapper` which was opened by the parsers.\n       * 3. 3rd span is the `.block` which was again opened by the parsers.\n       */\n      newLines += `${line}</span></span></span>`\n    } else {\n      /**\n       * Find the first match parser. To parsers cannot parse the same expression.\n       */\n      const matchingParser = parsers.find((parser) => parser.matches(lines, line, index))\n\n      if (matchingParser) {\n        const { jump, content } = matchingParser.getContent(lines, line, index)\n        newLines += content\n\n        /**\n         * Parsers returns the jump value, which indicates that we can jump x number of\n         * the lines without parsing them.\n         */\n        index = index + jump\n      } else {\n        newLines += `${line}</span>`\n      }\n    }\n    index++\n  }\n\n  return newLines\n}\n"],"names":["line","values","some","value","indexOf","identifier","content","match","matches","stack","index","utils","length","getContent","wrappedContent","trim","openingBlock","jump","operator","punctuation","self","Prism","global","hooks","add","env","language","highlightedCode","lines","split","newLines","matchingParser","parsers","find","parser","element","querySelectorAll","forEach","block","addEventListener","parentElement","classList","toggle"],"mappings":"gKAqBiBA,EAAMC,UACZA,EAAOC,KAAK,SAAUC,UACpBH,EAAKI,+BAAwBD,KAAY,gBAcxCH,EAAMC,UACTA,EAAOC,KAAK,SAAUC,UACpBH,EAAKI,4BAAqBD,KAAY,gBAarCH,UACHA,EAAKI,QAAQ,eAAiB,cAY7BC,4CAC2BA,iDAW5B,2CAYEC,OACHC,EAAQD,EAAQC,MAAM,iBACrBA,EAAQA,EAAM,GAAK,eAaZD,UACPA,EAAQF,QAAQ,mBAAqB,GAAKE,EAAQF,QAAQ,mBAAqB,OCjFxFI,iBAASC,EAAOH,EAASI,UAWnBC,EAAoBL,GAAU,QAC3BG,EAAMC,EAAQ,IAGZC,EAAoBF,EAAMC,EAAQ,IAAK,IAAK,QASjDD,EAAMG,OAASF,EAAQ,IAAMC,EAAiBL,MAI3CK,EAAiBF,EAAMC,EAAQ,IAAK,OAASC,EAAoBF,EAAMC,EAAQ,IAAK,QAgB7FG,oBAAYJ,EAAOH,EAASI,MACtBC,EAAoBL,GAAU,MAAO,KACjCQ,YAAoBR,EAAQS,kBAC5BC,YAAkBL,EAAgBL,WAAWK,EAAe,kBAEzDL,kBADQU,UAAeF,UAAiBH,KACxBM,KAAM,OAG3BC,YAAcT,EAAMC,EAAQ,cAC5BS,YAAiBV,EAAMC,EAAQ,cAC/BI,YAAoBR,EAAQS,kBAC5BC,YAAkBL,EAAgBL,WAAWK,EAAe,wBAGzDL,kBADQU,UAAeF,UAAiBI,UAAWC,UAAcR,KACjDM,KAAM,MC1DjCT,iBAASC,EAAOH,EAASI,UASnBC,EAAoBL,GAAU,QAC3BG,EAAMC,EAAQ,IAGZC,EAAoBF,EAAMC,EAAQ,IAAK,IAAK,QASjDD,EAAMG,OAASF,EAAQ,IAAMC,EAAiBL,MAI3CK,EAAiBF,EAAMC,EAAQ,IAAK,OAASC,EAAoBF,EAAMC,EAAQ,IAAK,QAgB7FG,oBAAYJ,EAAOH,EAASI,MACtBC,EAAoBL,GAAU,MAAO,KACjCQ,YAAoBR,EAAQS,kBAC5BC,YAAkBL,EAAgBL,WAAWK,EAAe,iBAEzDL,kBADQU,UAAeF,UAAiBH,KACxBM,KAAM,OAG3BC,YAAcT,EAAMC,EAAQ,cAC5BS,YAAiBV,EAAMC,EAAQ,cAC/BI,YAAoBR,EAAQS,kBAC5BC,YAAkBL,EAAgBL,WAAWK,EAAe,uBAGzDL,kBADQU,UAAeF,UAAiBI,UAAWC,UAAcR,KACjDM,KAAM,MCjEZ,oBAATG,OAAyBA,KAAKC,YAA6B,IAAXC,IAA2BA,EAAOD,QAI9FA,MAAME,MAAMC,IAAI,gBAAiB,SAACC,GACX,SAAjBA,EAAIC,WACND,EAAIE,gBCCO,SAAiBrB,WAC1BsB,EAAQtB,EAAQuB,MAAM,WACxBC,EAAW,GACXpB,EAAQ,mBAGJV,EAAO4B,EAAMlB,MAEfC,EAAqBX,GAQvB8B,aAAe9B,+BACV,KAIC+B,EAAiBC,EAAQC,KAAK,SAACC,UAAWA,EAAO1B,QAAQoB,EAAO5B,EAAMU,QAExEqB,EAAgB,OACQA,EAAelB,WAAWe,EAAO5B,EAAMU,GAAzDO,IAAAA,KAAMX,IAAAA,QACdwB,GAAYxB,EAMZI,GAAgBO,OAEhBa,aAAe9B,aAGnBU,KA/BKA,EAAQkB,EAAMhB,mBAkCdkB,EDxCmBI,CAAOT,EAAIE,oBAOrCN,MAAME,MAAMC,IAAI,WAAY,SAAUC,GACf,SAAjBA,EAAIC,UACND,EAAIU,QAAQC,iBAAiB,YAAYC,QAAQ,SAAUC,GACzDA,EAAMC,iBAAiB,QAAS,gBACzBC,cAAcC,UAAUC,OAAO"}